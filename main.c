#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/garbage.h"
#include "images/start.h"
#include "images/win.h"
#include "images/sprite.h"
#include "images/end.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  INITIAL,
  START,
  PLAY,
  WIN,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = INITIAL;
  struct pos b = {20, 0};
  int time = 0;
  char str1[100];
  char str2[100];

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttonsd
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    switch (state) {
      // Intial Loading State
      case INITIAL:
        waitForVBlank();
        drawFullScreenImageDMA(start);
        snprintf(str1, 100, "Welcome");
        snprintf(str2, 100, "Press Enter to Play");
        drawString(50, 100, str1, WHITE);
        drawString(70, 60, str2, WHITE);
        state = START;
        break;
      // Post Loading State
      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          waitForVBlank();
          fillScreenDMA(WHITE);
          snprintf(str2, 100, "Hit Backspace to Quit");
          drawString(0, 110, str2, BLACK);
          vBlankCounter = 0;
          state = PLAY;
        }
        break;
      // Main Game State
      case PLAY:
        waitForVBlank();
        // Update Time
        drawRectDMA(0, 25, 25, 10, WHITE);
        time = vBlankCounter / 60;
        snprintf(str1, 100, "Time:%d", time);
        drawString(0, 0, str1, BLACK);
        drawRectDMA(b.row, b.col, 16, 16, WHITE);

        // Movement
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          if (b.col < WIDTH - 16) {
            b.col++;
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (b.col > 0) {
            b.col--;
          }
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          if (b.row > 20) {
            b.row--;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          if (b.row < HEIGHT - 16) {
            b.row++;
          }
        }
        // Update Movement
        drawImageDMA(HEIGHT - 30, WIDTH - 30, 30, 30, end);
        drawImageDMA(b.row, b.col, 16, 16, sprite);
        // Reset
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = INITIAL;
          b.col = 0;
          b.row = 20;
          vBlankCounter = 0;
        }
        // Game Over
        if (b.row + 46 >= HEIGHT && b.col + 46 >= WIDTH) {
          drawFullScreenImageDMA(win);
          snprintf(str1, 100, "Time: %d Seconds", time);
          snprintf(str2, 100, "Press Enter to Play Again");
          drawString(60, 70, str1, WHITE);
          drawString(80, 45, str2, WHITE);
          state = WIN;
        }
        break;
      // Win State
      case WIN:
        waitForVBlank();
        // Play Again
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          fillScreenDMA(WHITE);
          snprintf(str2, 100, "Hit Backspace to Quit");
          drawString(0, 110, str2, BLACK);
          vBlankCounter = 0;
          b.col = 0;
          b.row = 20;
          state = PLAY;
        }
        // Reset
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = INITIAL;
          b.col = 0;
          b.row = 20;
          vBlankCounter = 0;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
